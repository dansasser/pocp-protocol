# POCP-Compat: The Post-Decoding Enforcement Layer

**Version:** 1.0  
**Status:** Release Candidate  
**Author:** Daniel T. Sasser II  
**Project:** Gorombo Agent Framework

---

## 1. Introduction

This document specifies the **Punctuated Output Control Protocol - Compatibility Layer (POCP-Compat)**. It is designed for application developers and API users who want to enforce fine-grained punctuation rules on text generated by a Large Language Model (LLM) when they do not have access to the model's internal pre-decoding process. This protocol provides a practical, standardized method for applying stylistic rules *after* the text has been generated.

## 2. Post-Decoding Process Flow

The POCP-Compat layer operates on the final output of an LLM. The logical flow is as follows:

1.  **Receive Generated Output:** Your application receives the complete text string or token stream from the LLM API.
2.  **Parse Rule Set:** Ingest and validate the user-defined JSON rule set.
3.  **Tokenize Output:** Use a compatible tokenizer to break the output into a token stream.
4.  **Validate & Apply Rules:** Iterate through the token stream and apply the rules. For substitution rules, a validation step should be performed to check for grammatical or semantic inconsistencies.
5.  **Handle Fallbacks:** If a rule application fails validation, execute the behavior defined in the `"fallback"` rule.
6.  **Reconstruct Final Text:** Decode the modified token stream back into a final, clean string, potentially including metadata from any "FLAG" fallbacks.

## 3. Rule Set Specification (JSON Schema)

The protocol is configured via a JSON object.

* `"disable": string[]`
    * An array of punctuation token names (e.g., `"EM_DASH"`) that should be removed or replaced.
* `"substitute": { [key: string]: string }`
    * An object mapping a disabled token to its replacement token (e.g., `"EM_DASH": "COMMA"`).
* `"fallback": string` **(Optional, Default: `"FLAG"`)**
    * Defines the behavior if a substitution is determined to be contextually invalid.
    * `"FLAG"`: Perform the substitution but include a warning or metadata flag in the output. An implementation could attach this metadata in a separate object or use a special character sequence.
    * `"REVERT"`: Ignore the rule for this instance and keep the original token.
    * `"OMIT"`: Omit the punctuation token entirely for this instance.
* `"limit": { [key: string]: number }`
    * Enforces a maximum count for specific punctuation tokens within the output.

## 4. Implementation Example (Pseudo-code)

```python
# Assume a tokenizer and a basic grammar checker are available
# from an_llm_tokenizer import tokenizer
# from a_grammar_checker import is_substitution_valid # Placeholder for context-aware grammar logic.

rule_set = {
  "disable": ["EM_DASH"],
  "substitute": { "EM_DASH": "COMMA" },
  "fallback": "REVERT"
}

EM_DASH_TOKEN_ID = 8212 
COMMA_TOKEN_ID = 44

def apply_pocp_compat(generated_text: str, rules: dict) -> str:
    token_ids = tokenizer.encode(generated_text)
    modified_tokens = []
    
    for i, token_id in enumerate(token_ids):
        is_invalid_substitution = False
        if token_id == EM_DASH_TOKEN_ID and "EM_DASH" in rules.get("disable", []):
            # The validation function is key to the fallback logic. Its implementation
            # is application-specific and is considered out of scope for this example.
            if not is_substitution_valid(token_ids, i, COMMA_TOKEN_ID):
                is_invalid_substitution = True

            if is_invalid_substitution and rules.get("fallback") == "REVERT":
                modified_tokens.append(token_id) # Revert to original em dash
            else:
                modified_tokens.append(COMMA_TOKEN_ID) # Perform substitution
        else:
            modified_tokens.append(token_id)
            
    final_text = tokenizer.decode(modified_tokens)
    return final_text
````

## 5. Relationship to POCP-Core

`POCP-Compat` is the practical implementation layer for developers. The ideal and most efficient implementation is defined in **`POCP-Core`**, which operates at the pre-decoding level.

